// Copyright 2017-present Open Networking Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

library identifier: 'cord-jenkins-libraries@master',
    retriever: modernSCM([
      $class: 'GitSCMSource',
      remote: 'https://gerrit.opencord.org/ci-management.git'
])

node ("${TestNodeName}") {
    // withKind is used to customize the port-forwarding toward the switch
    def withKind = false
    def VolthaEtcdPort = '2379'
    if (params.withKind != null){
        withKind = params.withKind
    }
    if (params.VolthaEtcdPort != null){
        VolthaEtcdPort = params.VolthaEtcdPort
    }
    timeout (100) {
        try {
            stage('Download Code') {
              getVolthaCode([
                branch: "${branch}",
                // volthaSystemTestsChange: "${volthaSystemTestsChange}",
                // volthaHelmChartsChange: "${volthaHelmChartsChange}",
              ])
            }
            stage ("Parse deployment configuration file") {
                sh returnStdout: true, script: "rm -rf ${configBaseDir}"
                sh returnStdout: true, script: "git clone -b master ${cordRepoUrl}/${configBaseDir}"
                if ( params.workFlow == "DT" ) {
                    deployment_config = readYaml file: "${configBaseDir}/${configDeploymentDir}/${configFileName}-DT.yaml"
                }
                else if ( params.workFlow == "TT" )
                {
                    deployment_config = readYaml file: "${configBaseDir}/${configDeploymentDir}/${configFileName}-TT.yaml"
                }
                else
                {
                    deployment_config = readYaml file: "${configBaseDir}/${configDeploymentDir}/${configFileName}.yaml"
                }
            }
            stage('Clean up') {
                timeout(15) {
                    script {
                        helmTeardown(["default", "infra", "voltha"])
                    }
                    timeout(1) {
                        sh returnStdout: false, script: """
                        #Remove all while true; do kubectl port-forward ...done; rules
                        for port_fwd_id in `ps -ax | grep "port-forward" | grep -E "onos|voltha" | grep "while true"| awk '{print \$1}'`;
                        do
                            kill -9 \$port_fwd_id || true
                        done

                        #Remove all kubectl port-forward rules
                        for port_fwd_id in `ps -ax | grep "port-forward" | grep -E "onos|voltha" | awk '{print \$1}'`;
                        do
                            kill -9 \$port_fwd_id || true
                        done
                        """
                    }
                }
            }
            stage('Install Voltha')  {
                timeout(20) {
                    // TODO support VOLTHA-2.7
                    // TODO support local charts (add parameters in the build)
                    def extraHelmFlags = "-f $WORKSPACE/${configBaseDir}/${configKubernetesDir}/voltha/${configFileName}.yml "

                    // temporary workaround expose ONOS node ports (pod-config needs to be updated)
                    extraHelmFlags += "--set onos-classic.onosSshPort=30115 "
                    extraHelmFlags += "--set onos-classic.onosApiPort=30120 "
                    extraHelmFlags += "--set onos-classic.onosOfPort=31653 "
                    extraHelmFlags += "--set onos-classic.individualOpenFlowNodePorts=true "

                    volthaDeploy([
                      workflow: workFlow.toLowerCase(),
                      extraHelmFlags: extraHelmFlags,
                      localCharts: false,
                      kubeconfig: "$WORKSPACE/${configBaseDir}/${configKubernetesDir}/${configFileName}.conf",
                      onosReplica: 3,
                      atomixReplica: 3,
                      kafkaReplica: 3,
                      etcdReplica: 3,
                    ])
                    sh """
                    JENKINS_NODE_COOKIE="dontKillMe" /usr/local/bin/kubectl port-forward --address 0.0.0.0 -n voltha svc/voltha1-voltha-api 55555:55555&
                    """
                    sh returnStdout: true, script: """
                    kubectl get pods --all-namespaces -o jsonpath="{range .items[*].status.containerStatuses[*]}{.image}{'\\t'}{.image}{'\\n'}" | sort | uniq
                    kubectl get pods --all-namespaces -o jsonpath="{range .items[*].status.containerStatuses[*]}{.image}{'\\t'}{.imageID}{'\\n'}" | sort | uniq
                    kubectl get nodes -o wide
                    kubectl get pods -n voltha -o wide
                    kubectl get pods
                    """
                }
            }
            if ( withKind && deployment_config.fabric_switches.size() > 0 ) {
                stage('OpenFlow port forward for aggregation switch') {
                    timeout(1) {
                        sh returnStdout: true, script: """
                        export KUBECONFIG=$WORKSPACE/${configBaseDir}/${configKubernetesDir}/${configFileName}.conf
                        #This uses the default route out, porperly configured is the management
                        mgmt_address=`ip route get 1 | awk '{print \$NF;exit}'`
                        JENKINS_NODE_COOKIE=dontkill kubectl port-forward -n default service/onos-onos-classic-hs --address=\$mgmt_address 6653:6653 >> /dev/null 2>&1 &
                        """
                    }
                }
            }
            if ( params.configurePod && params.profile != "Default" ) {
                stage('Push Tech-Profile') {
                    for(int i=0; i < deployment_config.olts.size(); i++) {
                        def tech_prof_directory = "XGS-PON"
                        // If no debian package is specified we default to GPON for the ADTRAN OLT.
                        if (!deployment_config.olts[i].containsKey("oltDebVersion") || deployment_config.olts[i].oltDebVersion.contains("asgvolt64")){
                            tech_prof_directory = "GPON"
                        }
                        timeout(1) {
                            out_push_tp = sh returnStatus: true, script: """
                            export KUBECONFIG=$WORKSPACE/${configBaseDir}/${configKubernetesDir}/${configFileName}.conf
                            etcd_container=\$(kubectl get pods | grep etcd | awk 'NR==1{print \$1}')
                            if [[ "${workFlow}" == "TT" ]]; then
                               kubectl cp $WORKSPACE/voltha-system-tests/tests/data/TechProfile-TT-HSIA.json \$etcd_container:/tmp/hsia.json
                               put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/hsia.json | ETCDCTL_API=3 etcdctl put service/voltha/technology_profiles/${tech_prof_directory}/64')
                               kubectl cp $WORKSPACE/voltha-system-tests/tests/data/TechProfile-TT-VoIP.json \$etcd_container:/tmp/voip.json
                               put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/voip.json | ETCDCTL_API=3 etcdctl put service/voltha/technology_profiles/${tech_prof_directory}/65')
                               kubectl cp $WORKSPACE/voltha-system-tests/tests/data/TechProfile-TT-MCAST.json \$etcd_container:/tmp/mcast.json
                               put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/mcast.json | ETCDCTL_API=3 etcdctl put service/voltha/technology_profiles/${tech_prof_directory}/66')
                            else
                               kubectl cp $WORKSPACE/voltha-system-tests/tests/data/TechProfile-${profile}.json \$etcd_container:/tmp/flexpod.json
                               put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/flexpod.json | ETCDCTL_API=3 etcdctl put service/voltha/technology_profiles/${tech_prof_directory}/64')
                            fi

                            """
                            return out_push_tp == 0
                        }
                        timeout(1) {
                            out_get_tp = sh returnStatus: true, script: """
                            export KUBECONFIG=$WORKSPACE/${configBaseDir}/${configKubernetesDir}/${configFileName}.conf
                            etcd_container=\$(kubectl get pods | grep etcd | awk 'NR==1{print \$1}')
                            get_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'ETCDCTL_API=3 etcdctl get --prefix service/voltha/technology_profiles/${tech_prof_directory}/64')
                            """
                            return out_get_tp == 0
                        }
                    }
                }
            }
            stage('Push Sadis-config') {
                timeout(1) {
                    sadis_out = sh returnStatus: true, script: """
                    export KUBECONFIG=$WORKSPACE/${configBaseDir}/${configKubernetesDir}/${configFileName}.conf
                    etcd_container=\$(kubectl get pods | grep etcd | awk 'NR==1{print \$1}')
                    kubectl cp $WORKSPACE/voltha-system-tests/tests/data/MIB_Alpha.json \$etcd_container:/tmp/MIB_Alpha.json
                    put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/MIB_Alpha.json | ETCDCTL_API=3 etcdctl put service/voltha/omci_mibs/templates/BRCM/BVM4K00BRA0915-0083/5023_020O02414')
                    kubectl cp $WORKSPACE/voltha-system-tests/tests/data/MIB_Scom.json \$etcd_container:/tmp/MIB_Scom.json
                    put_result=\$(kubectl exec -it \$etcd_container -- /bin/sh -c 'cat /tmp/MIB_Scom.json | ETCDCTL_API=3 etcdctl put service/voltha/omci_mibs/templates/SCOM/Glasfaser-Modem/090140.1.0.304')
                    if [[ "${workFlow}" == "DT" ]]; then
                        curl -sSL --user karaf:karaf -X POST -H Content-Type:application/json http://${deployment_config.nodes[0].ip}:30120/onos/v1/network/configuration --data @$WORKSPACE/voltha-system-tests/tests/data/${configFileName}-sadis-DT.json
                    elif [[ "${workFlow}" == "TT" ]]; then
                        curl -sSL --user karaf:karaf -X POST -H Content-Type:application/json http://${deployment_config.nodes[0].ip}:30120/onos/v1/network/configuration --data @$WORKSPACE/voltha-system-tests/tests/data/${configFileName}-sadis-TT.json
                    else
                        curl -sSL --user karaf:karaf -X POST -H Content-Type:application/json http://${deployment_config.nodes[0].ip}:30120/onos/v1/network/configuration --data @$WORKSPACE/voltha-system-tests/tests/data/${configFileName}-sadis.json
                    fi
                    """
                    return sadis_out == 0
                }
            }
            if ( deployment_config.fabric_switches.size() > 0 ) {
                stage('Switch Configurations in ONOS') {
                    timeout(1) {
                        def netcfg = "$WORKSPACE/${configBaseDir}/${configToscaDir}/voltha/${configFileName}-onos-netcfg-switch.json"
                        if (params.inBandManagement){
                             netcfg = "$WORKSPACE/${configBaseDir}/${configToscaDir}/voltha/${configFileName}-onos-netcfg-switch-inband.json"
                        }
                        netcfg_out = sh returnStatus: true, script: """
                        curl -sSL --user karaf:karaf -X POST -H Content-Type:application/json http://${deployment_config.nodes[0].ip}:30120/onos/v1/network/configuration --data @${netcfg}
                        curl -sSL --user karaf:karaf -X POST http://${deployment_config.nodes[0].ip}:30120/onos/v1/applications/org.onosproject.segmentrouting/active

                        """
                        return netcfg_out == 0
                    }
                    timeout(1) {
                        waitUntil {
                            sr_active_out = sh returnStatus: true, script: """
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "log:set TRACE org.opencord.dhcpl2relay"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "log:set TRACE org.opencord.aaa"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "log:set TRACE org.opencord.olt"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "log:set DEBUG org.onosproject.net.flowobjective.impl.FlowObjectiveManager"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "log:set DEBUG org.onosproject.net.flowobjective.impl.InOrderFlowObjectiveManager"
                            curl -sSL --user karaf:karaf -X GET http://${deployment_config.nodes[0].ip}:30120/onos/v1/applications/org.onosproject.segmentrouting | jq '.state' | grep ACTIVE
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "cfg set org.onosproject.provider.lldp.impl.LldpLinkProvider enabled false"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "cfg set org.onosproject.net.flow.impl.FlowRuleManager purgeOnDisconnection false"
                            sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "cfg set org.onosproject.net.meter.impl.MeterManager purgeOnDisconnection false"
                            """
                            return sr_active_out == 0
                        }
                    }
                    timeout(5) {
                        for(int i=0; i < deployment_config.hosts.src.size(); i++) {
                            for(int j=0; j < deployment_config.olts.size(); j++) {
                                def aggPort = -1
                                if(deployment_config.olts[j].serial == deployment_config.hosts.src[i].olt){
                                    aggPort = deployment_config.olts[j].aggPort
                                    if(aggPort == -1){
                                        throw new Exception("Upstream port for the olt is not configured, field aggPort is empty")
                                    }
                                    xconnect_out = sh returnStatus: true, script: """
                                    sleep 30 # NOTE why are we sleeping?
                                    version=\$(sshpass -p karaf ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p 30115 karaf@${deployment_config.nodes[0].ip} "summary" | grep version)
                                    sleep 10
                                    if [[ \$version == *"version=2.2"* ]]; then
                                        curl -X POST --user karaf:karaf --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{"deviceId": "${deployment_config.fabric_switches[0].device_id}", "vlanId": "${deployment_config.hosts.src[i].s_tag}", "endpoints": [${deployment_config.fabric_switches[0].bngPort},${aggPort}]}' 'http://${deployment_config.nodes[0].ip}:30120/onos/segmentrouting/xconnect'
                                    else
                                        curl -X POST --user karaf:karaf --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{"deviceId": "${deployment_config.fabric_switches[0].device_id}", "vlanId": "${deployment_config.hosts.src[i].s_tag}", "ports": [${deployment_config.fabric_switches[0].bngPort},${aggPort}]}' 'http://${deployment_config.nodes[0].ip}:30120/onos/segmentrouting/xconnect'
                                    fi
                                    """
                                }

                            }
                        }
                    }
                }
            }
            if ( params.reinstallOlt ) {
                stage('Reinstall OLT software') {
                    for(int i=0; i < deployment_config.olts.size(); i++) {
                        sh returnStdout: true, script: """
                        if [[ "${branch}" != "master" ]] && [[ "${params.inBandManagement}" == "true" ]]; then
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'kill -9 `pgrep -f "[b]ash /opt/openolt/openolt_dev_mgmt_daemon_process_watchdog"` || true'
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} "dpkg --install ${deployment_config.olts[i].oltDebVersion23}"
                        fi
                        if [[ "${branch}" != "master" ]] && [[ "${params.inBandManagement}" == "false" ]]; then
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} "dpkg --install ${deployment_config.olts[i].oltDebVersion23}"
                        fi
                        if [[ "${branch}" == "master" ]] && [[ "${params.inBandManagement}" == "true" ]]; then
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'kill -9 `pgrep -f "[b]ash /opt/openolt/openolt_dev_mgmt_daemon_process_watchdog"` || true'
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} "dpkg --install ${deployment_config.olts[i].oltDebVersion}"
                        fi
                        if [[ "${branch}" == "master" ]] && [[ "${params.inBandManagement}" == "false" ]]; then
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} "dpkg --install ${deployment_config.olts[i].oltDebVersion}"
                        fi
                        sleep 10
                        """
                        timeout(5) {
                            waitUntil {
                                olt_sw_present = sh returnStdout: true, script: """
                                if [ "${deployment_config.olts[i].oltDebVersion}" == *"asfvolt16"* ]; then
                                    sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'dpkg --list | grep asfvolt16 | wc -l'
                                else
                                    sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'dpkg --list | grep asgvolt64 | wc -l'
                                fi
                                if (${deployment_config.olts[i].fortygig}); then
                                    if [[ "${params.inBandManagement}" == "true" ]]; then
                                        ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                                        sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'mkdir -p /opt/openolt/'
                                        sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'cp /root/watchdog-script/* /opt/openolt/'
                                        sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'cp /root/bal_cli_appl/example_user_appl /broadcom'
                                        sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'cp in-band-startup-script/* /etc/init.d/'
                                    fi
                                fi
                                """
                                return olt_sw_present.toInteger() > 0
                            }
                        }
                    }
                }
                stage('Restart OLT processes') {
                    for(int i=0; i < deployment_config.olts.size(); i++) {
                        int waitTimerForOltUp = 360
                        if ( params.inBandManagement ) {
                            waitTimerForOltUp = 540
                        }
                        timeout(15) {
                            sh returnStdout: true, script: """
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'rm -f /var/log/openolt.log; rm -f /var/log/dev_mgmt_daemon.log; rm -f /var/log/openolt_process_watchdog.log; reboot' || true
                            sleep ${waitTimerForOltUp}
                            """
                        }
                        timeout(15) {
                            waitUntil {
                                devprocess = sh returnStdout: true, script: "sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'ps -ef | grep dev_mgmt_daemon | wc -l'"
                                return devprocess.toInteger() > 0
                            }
                        }
                        timeout(15) {
                            waitUntil {
                                openoltprocess = sh returnStdout: true, script: "sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'ps -ef | grep openolt | wc -l'"
                                return openoltprocess.toInteger() > 0
                            }
                        }
                    }
                }
            }
            /*if ( params.inBandManagement ) {
                stage('Reboot OLT') {
                    for(int i=0; i < deployment_config.olts.size(); i++) {
                        timeout(10) {
                            sh returnStdout: true, script: """
                            ssh-keyscan -H ${deployment_config.olts[i].sship} >> ~/.ssh/known_hosts
                            sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'rm -f /var/log/openolt.log; rm -f /var/log/dev_mgmt_daemon.log; rm -f /var/log/startup.log; rm -f /var/log/openolt_process_watchdog.log; reboot' || true
                            sleep 360
                            """
                        }
                        timeout(15) {
                            waitUntil {
                                devprocess = sh returnStdout: true, script: "sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'ps -ef | grep dev_mgmt_daemon | wc -l'"
                                return devprocess.toInteger() > 0
                            }
                        }
                        timeout(15) {
                            waitUntil {
                                openoltprocess = sh returnStdout: true, script: "sshpass -p ${deployment_config.olts[i].pass} ssh -l ${deployment_config.olts[i].user} ${deployment_config.olts[i].sship} 'ps -ef | grep openolt | wc -l'"
                                return openoltprocess.toInteger() > 0
                            }
                        }
                    }
                }
            }*/

            currentBuild.result = 'SUCCESS'
        } catch (err) {
            currentBuild.result = 'FAILURE'
            step([$class: 'Mailer', notifyEveryUnstableBuild: true, recipients: "${notificationEmail}", sendToIndividuals: false])
            throw err
        }
        echo "RESULT: ${currentBuild.result}"
    }
}
